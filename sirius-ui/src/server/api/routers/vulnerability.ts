import axios from "axios";
import { z } from "zod";
import { createTRPCRouter, publicProcedure } from "~/server/api/trpc";

import { env } from "~/env.mjs";
import { data as mockCveData, mockVulnerabilitySummaryData } from "~/utils/mock/cve"; //mock data

// Create an axios instance
const httpClient = axios.create({
  baseURL: env.SIRIUS_API_URL,
  timeout: 15000,
});

export type SiriusVulnerability = {
  vid: string;
  cvss: number;
  title: string;
  description: string;
  severity: string;
  cve: CveItem;
};

export interface NVDResponse {
  resultsPerPage: number;
  startIndex: number;
  totalResults: number;
  format: string;
  version: string;
  timestamp: string;
  vulnerabilities: DefCVEItem[];
}

export interface DefCVEItem {
  cve: CveItem;
}

export interface CveItem {
  id: string;
  sourceIdentifier: string;
  vulnStatus: string;
  published: string;
  lastModified: string;
  evaluatorComment?: string;
  evaluatorSolution?: string;
  evaluatorImpact?: string;
  cisaExploitAdd?: string;
  cisaActionDue?: string;
  cisaRequiredAction?: string;
  cisaVulnerabilityName?: string;
  cveTags?: CveTag[];
  descriptions: LangString[];
  references: Reference[];
  metrics?: Metrics;
  weaknesses?: Weakness[];
  configurations?: Config[];
  vendorComments?: VendorComment[];
}

export interface CveTag {
  sourceIdentifier: string;
  tags: string[];
}

export interface LangString {
  lang: string;
  value: string;
}

export interface Reference {
  url: string;
  source?: string;
  tags?: string[];
}

export interface Metrics {
  cvssMetricV40?: CvssV40[];
  cvssMetricV31?: CvssV31[];
  cvssMetricV30?: CvssV30[];
  cvssMetricV2?: CvssV2[];
}

export interface CvssV40 {
  source: string;
  type: string;
  cvssData: CvssDataV40;
}

export interface CvssV31 {
  source: string;
  type: string;
  cvssData: CvssDataV31;
  exploitabilityScore?: number;
  impactScore?: number;
}

export interface CvssV30 {
  source: string;
  type: string;
  cvssData: CvssDataV30;
  exploitabilityScore?: number;
  impactScore?: number;
}

export interface CvssV2 {
  source: string;
  type: string;
  cvssData: CvssDataV2;
  baseSeverity?: string;
  exploitabilityScore?: number;
  impactScore?: number;
  acInsufInfo?: boolean;
  obtainAllPrivilege?: boolean;
  obtainUserPrivilege?: boolean;
  obtainOtherPrivilege?: boolean;
  userInteractionRequired?: boolean;
}

export interface CvssDataV40 {
  version: string;
  vectorString: string;
}

export interface CvssDataV31 {
  version: string;
  vectorString: string;
  baseScore: number;
  baseSeverity: string;
  attackVector: string;
  attackComplexity: string;
  privilegesRequired: string;
  userInteraction: string;
  scope: string;
  confidentialityImpact: string;
  integrityImpact: string;
  availabilityImpact: string;
}

export interface CvssDataV30 {
  version: string;
  vectorString: string;
  baseScore: number;
  baseSeverity: string;
  attackVector: string;
  attackComplexity: string;
  privilegesRequired: string;
  userInteraction: string;
  scope: string;
  confidentialityImpact: string;
  integrityImpact: string;
  availabilityImpact: string;
}

export interface CvssDataV2 {
  version: string;
  vectorString: string;
  baseScore: number;
  accessVector: string;
  accessComplexity: string;
  authentication: string;
  confidentialityImpact: string;
  integrityImpact: string;
  availabilityImpact: string;
}

export interface Weakness {
  source: string;
  type: string;
  description: LangString[];
}

export interface Config {
  operator: string;
  negate?: boolean;
  nodes: Node[];
}

export interface Node {
  operator: string;
  negate?: boolean;
  cpeMatch?: CpeMatch[];
}

export interface CpeMatch {
  vulnerable: boolean;
  criteria: string;
  matchCriteriaId: string;
  versionStartExcluding?: string;
  versionStartIncluding?: string;
  versionEndExcluding?: string;
  versionEndIncluding?: string;
}

export interface VendorComment {
  organization: string;
  comment: string;
  lastModified: string;
}

export interface VulnerabilitySummary {
  cve: string;
  cvss: number;
  description: string;
  published: string;
  severity: "informational" | "low" | "medium" | "high" | "critical";
  count: number;
}


export const vulnerabilityRouter = createTRPCRouter({
  // Retrieve a single vulnerability data
  getVulnerability: publicProcedure
    .input(z.object({ id: z.string() })) 
    .query(async ({ input }) => {
      const { id } = input;
      try {
        if (!id) {
          throw new Error("No ID provided");
        }
        console.log("ID:", id);
        // const { data: vuln } = await httpClient.get<{
        //   data: SiriusVulnerability;
        // }>(`vulnerability/${id}`);
        // console.log("Vulnerability:", vuln);
        // 
      
        const response = await httpClient.get<CveItem>(`vulnerability/${id}`);
        const vuln = response.data;
        console.log("Vulnerability:", vuln);

        //Mock data
        // return mockCveData;

        return vuln ?? null;
      } catch (error) {
        // Handle the error accordingly
        console.error("Error fetching host: vulnerability.ts");
        // console.error(error);
        return null;
      }
    }),
  // Retrieve a summary of all vulnerabilities for the environment
  getAllVulnerabilities: publicProcedure.query(async () => {
    try {
      // const response = await httpClient.get<[VulnerabilitySummary]>("host/vulnerabilities/all");
      // const vulnerabilities = response.data;

      return mockVulnerabilitySummaryData;
    } catch (error) {
      // Handle the error accordingly
      console.error("Error fetching vulnerabilities:", error);
      return [];
    }
  }),
});

